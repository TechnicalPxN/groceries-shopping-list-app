var __BUNDLE_START_TIME__=globalThis.nativePerformanceNow?nativePerformanceNow():Date.now(),__DEV__=false,process=globalThis.process||{},__METRO_GLOBAL_PREFIX__='';
!(function(e){"use strict";e.__r=i,e[`${__METRO_GLOBAL_PREFIX__}__d`]=function(e,n,o){if(t.has(n))return;const i={dependencyMap:o,factory:e,hasError:!1,importedAll:r,importedDefault:r,isInitialized:!1,publicModule:{exports:{}}};t.set(n,i)},e.__c=o,e.__registerSegment=function(e,r,n){p[e]=r,n&&n.forEach((r=>{t.has(r)||h.has(r)||h.set(r,e)}))};var t=o();const r={},{hasOwnProperty:n}={};function o(){return t=new Map}function i(e){const r=e,n=t.get(r);return n&&n.isInitialized?n.publicModule.exports:d(r,n)}function l(e){const n=e,o=t.get(n);if(o&&o.importedDefault!==r)return o.importedDefault;const l=i(n),u=l&&l.__esModule?l.default:l;return t.get(n).importedDefault=u}function u(e){const o=e,l=t.get(o);if(l&&l.importedAll!==r)return l.importedAll;const u=i(o);let c;if(u&&u.__esModule)c=u;else{if(c={},u)for(const e in u)n.call(u,e)&&(c[e]=u[e]);c.default=u}return t.get(o).importedAll=c}i.importDefault=l,i.importAll=u,i.context=function(){throw new Error("The experimental Metro feature `require.context` is not enabled in your project.")},i.resolveWeak=function(){throw new Error("require.resolveWeak cannot be called dynamically.")};let c=!1;function d(t,r){if(!c&&e.ErrorUtils){let n;c=!0;try{n=g(t,r)}catch(t){e.ErrorUtils.reportFatalError(t)}return c=!1,n}return g(t,r)}const a=16,s=65535;function f(e){return{segmentId:e>>>a,localId:e&s}}i.unpackModuleId=f,i.packModuleId=function(e){return(e.segmentId<<a)+e.localId};const p=[],h=new Map;function g(r,n){if(!n&&p.length>0){const e=h.get(r)??0,o=p[e];null!=o&&(o(r),n=t.get(r),h.delete(r))}const o=e.nativeRequire;if(!n&&o){const{segmentId:e,localId:i}=f(r);o(i,e),n=t.get(r)}if(!n)throw _(r);if(n.hasError)throw n.error;n.isInitialized=!0;const{factory:c,dependencyMap:d}=n;try{const t=n.publicModule;return t.id=r,c(e,i,l,u,t,t.exports,d),n.factory=void 0,n.dependencyMap=void 0,t.exports}catch(e){throw n.hasError=!0,n.error=e,n.isInitialized=!1,n.publicModule.exports=void 0,e}}function _(e){return Error('Requiring unknown module "'+e+'".')}})('undefined'!=typeof globalThis?globalThis:'undefined'!=typeof global?global:'undefined'!=typeof window?window:this);
!(function(e){e.$$require_external=require})('undefined'!=typeof globalThis?globalThis:'undefined'!=typeof global?global:'undefined'!=typeof window?window:this);
'undefined'!=typeof globalThis?globalThis:'undefined'!=typeof global?global:'undefined'!=typeof window&&window;
!(function(r){let l=0,n=!0===r.RN$useAlwaysAvailableJSErrorHandling?r.RN$handleException:(r,l)=>{throw r};const t={setGlobalHandler(r){n=r},getGlobalHandler:()=>n,reportError(r){n&&n(r,!1)},reportFatalError(r){n&&n(r,!0)},applyWithGuard(r,n,e,a,o){try{return l++,r.apply(n,e)}catch(r){t.reportError(r)}finally{l--}return null},applyWithGuardIfNeeded:(r,l,n)=>t.inGuard()?r.apply(l,n):(t.applyWithGuard(r,l,n),null),inGuard:()=>!!l,guard(r,l,n){if('function'!=typeof r)return console.warn('A function must be passed to ErrorUtils.guard, got ',r),null;const e=l??r.name??'<generated guard>';return function(...l){return t.applyWithGuard(r,n??this,l,null,e)}}};r.ErrorUtils=t})('undefined'!=typeof globalThis?globalThis:'undefined'!=typeof global?global:'undefined'!=typeof window?window:this);
__d((function(g,r,i,a,m,_e,d){m.exports=function(e){return e&&e.__esModule?e:{default:e}},m.exports.__esModule=!0,m.exports.default=m.exports}),24,[]);
__d((function(g,r,i,a,m,e,d){m.exports=$$require_external('node:crypto')}),1228,[]);
__d((function(g,r,i,a,m,e,d){var t=r(d[0]);Object.defineProperty(e,"__esModule",{value:!0}),e.POST=async function(t){try{console.log("\ud83d\udcf1 Expo webhook received");const n=t.headers.get("expo-signature");if(!n)return console.error("\u274c No signature provided"),new Response("No signature provided",{status:401});if(!process.env.EXPO_WEBHOOK_SECRET)return console.error("\u274c EXPO_WEBHOOK_SECRET not configured"),new Response("Server configuration error",{status:500});const c=await t.text();console.log("\ud83d\udd11 Verifying signature...");const l=s.default.createHmac("sha1",process.env.EXPO_WEBHOOK_SECRET);l.update(c);if(n!==`sha1=${l.digest("hex")}`)return console.error("\u274c Signature verification failed"),new Response("Invalid signature",{status:403});console.log("\u2705 Signature verified successfully");const u=JSON.parse(c),p=u.status.toUpperCase(),f=`\n${"finished"===u.status?"\u2705":"errored"===u.status?"\u274c":"\u26a0\ufe0f"} Build ${p}\n\n\ud83d\udd27 Project: ${u.projectName}\n\ud83d\udcf1 Platform: ${u.platform}\n\ud83c\udff7\ufe0f Version: ${u.metadata.appVersion} (${u.metadata.appBuildVersion})\n${u.metadata.gitCommitMessage?`\ud83d\udcdd Commit: ${u.metadata.gitCommitMessage}`:""}\n${u.buildDetailsPageUrl?`\n\ud83d\udd0d Details: ${u.buildDetailsPageUrl}`:""}\n${u.artifacts?.buildUrl?`\n\ud83d\udce6 Build URL: ${u.artifacts.buildUrl}`:""}\n${u.error?`\n\u26a0\ufe0f Error: ${u.error.message}`:""}\n    `.trim();return await o(f),console.log("\ud83d\udce8 Telegram notification sent"),new Response("OK!",{status:200})}catch(t){return console.error("\u274c Webhook processing error:",t),new Response("Internal server error",{status:500})}};var s=t(r(d[1]));async function o(t){const s=`https://api.telegram.org/bot${process.env.TELEGRAM_BOT_TOKEN}/sendMessage`;try{const o=await fetch(s,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({chat_id:process.env.TELEGRAM_GROUP_ID,text:t,parse_mode:"HTML"})});if(!o.ok)throw new Error(`Telegram API error: ${o.status}`)}catch(t){console.error("Failed to send Telegram message:",t)}}}),1464,[24,1228]);
module.exports = __r(1464);